From: Jim Wilson <jimw@sifive.com>
Date: Wed, 3 Apr 2019 11:27:02 -0700
Subject: RISC-V: Add sifive-7 pipeline description.

	backport patches from upstream

	* config/riscv/generic.md (generic_alu, generic_load, generic_store)
	(generic_xfer, generic_branch, generic_imul, generic_idivsi)
	(generic_idivdi, generic_fmul_single, generic_fmul_double)
	(generic_fdiv, generic_fsqrt): Add check for generic tune.
	(generic_alu): Add auipc to type list.
	* config/riscv/riscv-opts.h (enum riscv_microarchitecture_type): New.
	(riscv_microarchitecture): Declare.
	* config/riscv/riscv-protos.h (riscv_store_data_bypass_p): Declare.
	* config/riscv/riscv.c (struct riscv_cpu_info): Add microarchitecture
	field.
	(riscv_microarchitecture): New.
	(sifive_7_tune_info): New.
	(riscv_cpu_info_table): Add microarchitecture value for rocket and
	size.  Add sifive-3-series, sifive-5-series, and sifive-7-series
	entries.
	(riscv_store_data_bypass_p): New.
	(riscv_option_override): Set riscv_microarchitecture from
	cpu->microarchitecture.
	* config/riscv/riscv.md: Include sifive-7.md.
	(type): Add auipc.
	(tune): New.
	(auipc<mode>): Change type to auipc.
	(restore_stack_nonlocal): New.
	* config/riscv/sifive-7.md: New.
	* doc/invoke.texi (RISC-V Options): Update mtune docs.

	RISC-V: Add short-forward-branch optimization for sifive-7 core.

	gcc/
	* config/riscv/constraints.md (L): New.
	* config/riscv/predicates.md (lui_operand): New.
	(sfb_alu_operand): New.
	* config/riscv/riscv-protos.h (riscv_expand_conditional_move): Declare.
	* config/riscv/riscv.c (riscv_expand_conditional_move): New.
	(riscv_print_operand): Add support for 'w' and 'y'.  Update comment.
	* config/riscv/riscv.h (TARGET_SFB_ALU): New.
	* config/riscv/riscv.md (type): Add sfb_alu.
	(branch_order<mode>, branch_zero<mode>): Delete.
	(branch<mode>): New, combined from the two deleted patterns.
	(mov<mode>cc, mov<GPR:mode><X:mode>cc): New, using TARGET_SFB_ALU.
	* config/riscv/sifive-7.md: Update bypasses for sfb alu support.
	(sifive_7_sfb_alu): New.
---
 gcc/config/riscv/constraints.md |   5 ++
 gcc/config/riscv/generic.md     |  44 ++++++++-----
 gcc/config/riscv/predicates.md  |   8 +++
 gcc/config/riscv/riscv-opts.h   |   7 ++
 gcc/config/riscv/riscv-protos.h |   2 +
 gcc/config/riscv/riscv.c        | 142 ++++++++++++++++++++++++++++++++++++++--
 gcc/config/riscv/riscv.h        |  11 ++++
 gcc/config/riscv/riscv.md       |  79 +++++++++++++++++-----
 gcc/config/riscv/sifive-7.md    | 128 ++++++++++++++++++++++++++++++++++++
 gcc/doc/invoke.texi             |  11 +++-
 10 files changed, 398 insertions(+), 39 deletions(-)
 create mode 100644 gcc/config/riscv/sifive-7.md

diff --git a/gcc/config/riscv/constraints.md b/gcc/config/riscv/constraints.md
index 9f612b3..231ccfe 100644
--- a/gcc/config/riscv/constraints.md
+++ b/gcc/config/riscv/constraints.md
@@ -54,6 +54,11 @@
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, 0, IMM_REACH-1)")))
 
+(define_constraint "L"
+  "A U-type 20-bit signed immediate."
+  (and (match_code "const_int")
+       (match_test "LUI_OPERAND (ival)")))
+
 ;; Floating-point constant +0.0, used for FCVT-based moves when FMV is
 ;; not available in RV32.
 (define_constraint "G"
diff --git a/gcc/config/riscv/generic.md b/gcc/config/riscv/generic.md
index ba05b6a..2a58e86 100644
--- a/gcc/config/riscv/generic.md
+++ b/gcc/config/riscv/generic.md
@@ -26,53 +26,65 @@
 (define_cpu_unit "fdivsqrt" "pipe0")
 
 (define_insn_reservation "generic_alu" 1
-  (eq_attr "type" "unknown,const,arith,shift,slt,multi,nop,logical,move")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "unknown,const,arith,shift,slt,multi,auipc,nop,logical,move"))
   "alu")
 
 (define_insn_reservation "generic_load" 3
-  (eq_attr "type" "load,fpload")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "load,fpload"))
   "alu")
 
 (define_insn_reservation "generic_store" 1
-  (eq_attr "type" "store,fpstore")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "store,fpstore"))
   "alu")
 
 (define_insn_reservation "generic_xfer" 3
-  (eq_attr "type" "mfc,mtc,fcvt,fmove,fcmp")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "mfc,mtc,fcvt,fmove,fcmp"))
   "alu")
 
 (define_insn_reservation "generic_branch" 1
-  (eq_attr "type" "branch,jump,call")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "branch,jump,call"))
   "alu")
 
 (define_insn_reservation "generic_imul" 10
-  (eq_attr "type" "imul")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "imul"))
   "imuldiv*10")
 
 (define_insn_reservation "generic_idivsi" 34
-  (and (eq_attr "type" "idiv")
-       (eq_attr "mode" "SI"))
+  (and (eq_attr "tune" "generic")
+       (and (eq_attr "type" "idiv")
+	    (eq_attr "mode" "SI")))
   "imuldiv*34")
 
 (define_insn_reservation "generic_idivdi" 66
-  (and (eq_attr "type" "idiv")
-       (eq_attr "mode" "DI"))
+  (and (eq_attr "tune" "generic")
+       (and (eq_attr "type" "idiv")
+	    (eq_attr "mode" "DI")))
   "imuldiv*66")
 
 (define_insn_reservation "generic_fmul_single" 5
-  (and (eq_attr "type" "fadd,fmul,fmadd")
-       (eq_attr "mode" "SF"))
+  (and (eq_attr "tune" "generic")
+       (and (eq_attr "type" "fadd,fmul,fmadd")
+	    (eq_attr "mode" "SF")))
   "alu")
 
 (define_insn_reservation "generic_fmul_double" 7
-  (and (eq_attr "type" "fadd,fmul,fmadd")
-       (eq_attr "mode" "DF"))
+  (and (eq_attr "tune" "generic")
+       (and (eq_attr "type" "fadd,fmul,fmadd")
+	    (eq_attr "mode" "DF")))
   "alu")
 
 (define_insn_reservation "generic_fdiv" 20
-  (eq_attr "type" "fdiv")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "fdiv"))
   "fdivsqrt*20")
 
 (define_insn_reservation "generic_fsqrt" 25
-  (eq_attr "type" "fsqrt")
+  (and (eq_attr "tune" "generic")
+       (eq_attr "type" "fsqrt"))
   "fdivsqrt*25")
diff --git a/gcc/config/riscv/predicates.md b/gcc/config/riscv/predicates.md
index 93b652f..f10a5b6 100644
--- a/gcc/config/riscv/predicates.md
+++ b/gcc/config/riscv/predicates.md
@@ -27,6 +27,14 @@
   (ior (match_operand 0 "const_arith_operand")
        (match_operand 0 "register_operand")))
 
+(define_predicate "lui_operand"
+  (and (match_code "const_int")
+       (match_test "LUI_OPERAND (INTVAL (op))")))
+
+(define_predicate "sfb_alu_operand"
+  (ior (match_operand 0 "arith_operand")
+       (match_operand 0 "lui_operand")))
+
 (define_predicate "const_csr_operand"
   (and (match_code "const_int")
        (match_test "IN_RANGE (INTVAL (op), 0, 31)")))
diff --git a/gcc/config/riscv/riscv-opts.h b/gcc/config/riscv/riscv-opts.h
index b7ed72e..55d75e3 100644
--- a/gcc/config/riscv/riscv-opts.h
+++ b/gcc/config/riscv/riscv-opts.h
@@ -39,4 +39,11 @@ enum riscv_code_model {
 };
 extern enum riscv_code_model riscv_cmodel;
 
+/* Keep this list in sync with define_attr "tune" in riscv.md.  */
+enum riscv_microarchitecture_type {
+  generic,
+  sifive_7
+};
+extern enum riscv_microarchitecture_type riscv_microarchitecture;
+
 #endif /* ! GCC_RISCV_OPTS_H */
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index f158ed0..ed965d6 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -59,6 +59,7 @@ extern const char *riscv_output_return ();
 extern void riscv_expand_int_scc (rtx, enum rtx_code, rtx, rtx);
 extern void riscv_expand_float_scc (rtx, enum rtx_code, rtx, rtx);
 extern void riscv_expand_conditional_branch (rtx, enum rtx_code, rtx, rtx);
+extern void riscv_expand_conditional_move (rtx, rtx, rtx, rtx_code, rtx, rtx);
 #endif
 extern rtx riscv_legitimize_call_address (rtx);
 extern void riscv_set_return_address (rtx, rtx);
@@ -71,6 +72,7 @@ extern bool riscv_epilogue_uses (unsigned int);
 extern bool riscv_can_use_return_insn (void);
 extern rtx riscv_function_value (const_tree, const_tree, enum machine_mode);
 extern bool riscv_expand_block_move (rtx, rtx, rtx);
+extern bool riscv_store_data_bypass_p (rtx_insn *, rtx_insn *);
 
 /* Routines implemented in riscv-c.c.  */
 void riscv_cpu_cpp_builtins (cpp_reader *);
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index ed24442..46f9040 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -236,6 +236,9 @@ struct riscv_cpu_info {
   /* This CPU's canonical name.  */
   const char *name;
 
+  /* Which automaton to use for tuning.  */
+  enum riscv_microarchitecture_type microarchitecture;
+
   /* Tuning parameters for this CPU.  */
   const struct riscv_tune_info *tune_info;
 };
@@ -251,6 +254,9 @@ unsigned riscv_stack_boundary;
 /* Which tuning parameters to use.  */
 static const struct riscv_tune_info *tune_info;
 
+/* Which automaton to use for tuning.  */
+enum riscv_microarchitecture_type riscv_microarchitecture;
+
 /* Index R is the smallest register class that contains register R.  */
 const enum reg_class riscv_regno_to_class[FIRST_PSEUDO_REGISTER] = {
   GR_REGS,	GR_REGS,	GR_REGS,	GR_REGS,
@@ -285,6 +291,19 @@ static const struct riscv_tune_info rocket_tune_info = {
   true,						/* slow_unaligned_access */
 };
 
+/* Costs to use when optimizing for Sifive 7 Series.  */
+static const struct riscv_tune_info sifive_7_tune_info = {
+  {COSTS_N_INSNS (4), COSTS_N_INSNS (5)},	/* fp_add */
+  {COSTS_N_INSNS (4), COSTS_N_INSNS (5)},	/* fp_mul */
+  {COSTS_N_INSNS (20), COSTS_N_INSNS (20)},	/* fp_div */
+  {COSTS_N_INSNS (4), COSTS_N_INSNS (4)},	/* int_mul */
+  {COSTS_N_INSNS (6), COSTS_N_INSNS (6)},	/* int_div */
+  2,						/* issue_rate */
+  4,						/* branch_cost */
+  3,						/* memory_cost */
+  true,						/* slow_unaligned_access */
+};
+
 /* Costs to use when optimizing for size.  */
 static const struct riscv_tune_info optimize_size_tune_info = {
   {COSTS_N_INSNS (1), COSTS_N_INSNS (1)},	/* fp_add */
@@ -321,8 +340,11 @@ static const struct attribute_spec riscv_attribute_table[] =
 
 /* A table describing all the processors GCC knows about.  */
 static const struct riscv_cpu_info riscv_cpu_info_table[] = {
-  { "rocket", &rocket_tune_info },
-  { "size", &optimize_size_tune_info },
+  { "rocket", generic, &rocket_tune_info },
+  { "sifive-3-series", generic, &rocket_tune_info },
+  { "sifive-5-series", generic, &rocket_tune_info },
+  { "sifive-7-series", sifive_7, &sifive_7_tune_info },
+  { "size", generic, &optimize_size_tune_info },
 };
 
 /* Return the riscv_cpu_info entry for the given name string.  */
@@ -2242,6 +2264,18 @@ riscv_expand_conditional_branch (rtx label, rtx_code code, rtx op0, rtx op1)
   emit_jump_insn (gen_condjump (condition, label));
 }
 
+/* If (CODE OP0 OP1) holds, move CONS to DEST; else move ALT to DEST.  */
+
+void
+riscv_expand_conditional_move (rtx dest, rtx cons, rtx alt, rtx_code code,
+			       rtx op0, rtx op1)
+{
+  riscv_emit_int_compare (&code, &op0, &op1);
+  rtx cond = gen_rtx_fmt_ee (code, GET_MODE (op0), op0, op1);
+  emit_insn (gen_rtx_SET (dest, gen_rtx_IF_THEN_ELSE (GET_MODE (dest), cond,
+						      cons, alt)));
+}
+
 /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at
    least PARM_BOUNDARY bits of alignment, but will be given anything up
    to PREFERRED_STACK_BOUNDARY bits if the type requires it.  */
@@ -3094,6 +3128,8 @@ riscv_memmodel_needs_release_fence (enum memmodel model)
    'C'	Print the integer branch condition for comparison OP.
    'A'	Print the atomic operation suffix for memory model OP.
    'F'	Print a FENCE if the memory model requires a release.
+   'w'	Print nothing if OP is zero, otherwise print OP followed by a comma.
+   'y'	Print 'z' if OP is zero, otherwise print nothing.
    'z'	Print x0 if OP is zero, otherwise print OP normally.
    'x'	Print CONST_INT OP as a CSR register name or as a hex number.
    'i'	Print i if the operand is not a register.  */
@@ -3140,9 +3176,13 @@ riscv_print_operand (FILE *file, rtx op, int letter)
       switch (code)
 	{
 	case REG:
-	  if (letter && letter != 'z')
+	  if (letter && letter == 'y')
+	    break;
+	  else if (letter && letter != 'w' && letter != 'z')
 	    output_operand_lossage ("invalid use of '%%%c'", letter);
 	  fprintf (file, "%s", reg_names[REGNO (op)]);
+	  if (letter == 'w')
+	    fputs(",", file);
 	  break;
 
 	case MEM:
@@ -3153,7 +3193,11 @@ riscv_print_operand (FILE *file, rtx op, int letter)
 	  break;
 
 	default:
-	  if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))
+	  if (letter == 'w')
+	    break;
+	  else if (letter == 'y' && op == CONST0_RTX (GET_MODE (op)))
+	    fputs ("z", file);
+	  else if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))
 	    fputs (reg_names[GP_REG_FIRST], file);
 	  else if (letter == 'x' && GET_CODE (op) == CONST_INT)
 	    {
@@ -3181,7 +3225,7 @@ riscv_print_operand (FILE *file, rtx op, int letter)
 	      else
 		asm_fprintf (file, "0x%wx", reg_num);
 	    }
-	  else if (letter && letter != 'z')
+	  else if (letter && letter != 'y' && letter != 'z')
 	    output_operand_lossage ("invalid use of '%%%c'", letter);
 	  else
 	    output_addr_const (file, riscv_strip_unspec_address (op));
@@ -4153,6 +4197,93 @@ riscv_can_use_return_insn (void)
 	  && ! cfun->machine->interrupt_handler_p);
 }
 
+/* Given that there exists at least one variable that is set (produced)
+   by OUT_INSN and read (consumed) by IN_INSN, return true iff
+   IN_INSN represents one or more memory store operations and none of
+   the variables set by OUT_INSN is used by IN_INSN as the address of a
+   store operation.  If either IN_INSN or OUT_INSN does not represent
+   a "single" RTL SET expression (as loosely defined by the
+   implementation of the single_set function) or a PARALLEL with only
+   SETs, CLOBBERs, and USEs inside, this function returns false.
+
+   Borrowed from rs6000, riscv_store_data_bypass_p checks for certain
+   conditions that result in assertion failures in the generic
+   store_data_bypass_p function and returns FALSE in such cases.
+
+   This is required to make -msave-restore work with the sifive-7
+   pipeline description.  */
+
+bool
+riscv_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)
+{
+  rtx out_set, in_set;
+  rtx out_pat, in_pat;
+  rtx out_exp, in_exp;
+  int i, j;
+
+  in_set = single_set (in_insn);
+  if (in_set)
+    {
+      if (MEM_P (SET_DEST (in_set)))
+	{
+	  out_set = single_set (out_insn);
+	  if (!out_set)
+	    {
+	      out_pat = PATTERN (out_insn);
+	      if (GET_CODE (out_pat) == PARALLEL)
+		{
+		  for (i = 0; i < XVECLEN (out_pat, 0); i++)
+		    {
+		      out_exp = XVECEXP (out_pat, 0, i);
+		      if ((GET_CODE (out_exp) == CLOBBER)
+			  || (GET_CODE (out_exp) == USE))
+			continue;
+		      else if (GET_CODE (out_exp) != SET)
+			return false;
+		    }
+		}
+	    }
+	}
+    }
+  else
+    {
+      in_pat = PATTERN (in_insn);
+      if (GET_CODE (in_pat) != PARALLEL)
+	return false;
+
+      for (i = 0; i < XVECLEN (in_pat, 0); i++)
+	{
+	  in_exp = XVECEXP (in_pat, 0, i);
+	  if ((GET_CODE (in_exp) == CLOBBER) || (GET_CODE (in_exp) == USE))
+	    continue;
+	  else if (GET_CODE (in_exp) != SET)
+	    return false;
+
+	  if (MEM_P (SET_DEST (in_exp)))
+	    {
+	      out_set = single_set (out_insn);
+	      if (!out_set)
+		{
+		  out_pat = PATTERN (out_insn);
+		  if (GET_CODE (out_pat) != PARALLEL)
+		    return false;
+		  for (j = 0; j < XVECLEN (out_pat, 0); j++)
+		    {
+		      out_exp = XVECEXP (out_pat, 0, j);
+		      if ((GET_CODE (out_exp) == CLOBBER)
+			  || (GET_CODE (out_exp) == USE))
+			continue;
+		      else if (GET_CODE (out_exp) != SET)
+			return false;
+		    }
+		}
+	    }
+	}
+    }
+
+  return store_data_bypass_p (out_insn, in_insn);
+}
+
 /* Implement TARGET_SECONDARY_MEMORY_NEEDED.
 
    When floating-point registers are wider than integer ones, moves between
@@ -4400,6 +4531,7 @@ riscv_option_override (void)
   /* Handle -mtune.  */
   cpu = riscv_parse_cpu (riscv_tune_string ? riscv_tune_string :
 			 RISCV_TUNE_STRING_DEFAULT);
+  riscv_microarchitecture = cpu->microarchitecture;
   tune_info = optimize_size ? &optimize_size_tune_info : cpu->tune_info;
 
   /* Use -mtune's setting for slow_unaligned_access, even when optimizing
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index 3c9f96d..f7f1c13 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -659,6 +659,17 @@ typedef struct {
 #define BRANCH_COST(speed_p, predictable_p) \
   ((!(speed_p) || (predictable_p)) ? 2 : riscv_branch_cost)
 
+/* True if the target optimizes short forward branches around integer
+   arithmetic instructions into predicated operations, e.g., for
+   conditional-move operations.  The macro assumes that all branch
+   instructions (BEQ, BNE, BLT, BLTU, BGE, BGEU, C.BEQZ, and C.BNEZ)
+   support this feature.  The macro further assumes that any integer
+   arithmetic and logical operation (ADD[I], SUB, SLL[I], SRL[I], SRA[I],
+   SLT[I][U], AND[I], XOR[I], OR[I], LUI, AUIPC, and their compressed
+   counterparts, including C.MV and C.LI) can be in the branch shadow.  */
+
+#define TARGET_SFB_ALU (riscv_microarchitecture == sifive_7)
+
 #define LOGICAL_OP_NON_SHORT_CIRCUIT 0
 
 /* Control the assembler format that we output.  */
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index 7020816..b186aa7 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -174,7 +174,7 @@
 (define_attr "type"
   "unknown,branch,jump,call,load,fpload,store,fpstore,
    mtc,mfc,const,arith,logical,shift,slt,imul,idiv,move,fmove,fadd,fmul,
-   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,nop,ghost"
+   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,sfb_alu,nop,ghost"
   (cond [(eq_attr "got" "load") (const_string "load")
 
 	 ;; If a doubleword move uses these expensive instructions,
@@ -253,6 +253,12 @@
 ;; Is copying of this instruction disallowed?
 (define_attr "cannot_copy" "no,yes" (const_string "no"))
 
+;; Microarchitectures we know how to tune for.
+;; Keep this in sync with enum riscv_microarchitecture.
+(define_attr "tune"
+  "generic,sifive_7"
+  (const (symbol_ref "((enum attr_tune) riscv_microarchitecture)")))
+
 ;; Describe a user's asm statement.
 (define_asm_attributes
   [(set_attr "type" "multi")])
@@ -1255,7 +1261,7 @@
 	    UNSPEC_AUIPC))]
   ""
   ".LA%2: auipc\t%0,%h1"
-  [(set_attr "type" "arith")
+  [(set_attr "type" "auipc")
    (set_attr "cannot_copy" "yes")])
 
 ;; Instructions for adding the low 12 bits of an address to a register.
@@ -1805,31 +1811,52 @@
 
 ;; Conditional branches
 
-(define_insn "*branch_order<mode>"
+(define_insn "*branch<mode>"
   [(set (pc)
 	(if_then_else
 	 (match_operator 1 "order_operator"
 			 [(match_operand:X 2 "register_operand" "r")
-			  (match_operand:X 3 "register_operand" "r")])
+			  (match_operand:X 3 "reg_or_0_operand" "rJ")])
 	 (label_ref (match_operand 0 "" ""))
 	 (pc)))]
   ""
-  "b%C1\t%2,%3,%0"
+  "b%C1%y3\t%2,%w3%0"
   [(set_attr "type" "branch")
    (set_attr "mode" "none")])
 
-(define_insn "*branch_zero<mode>"
-  [(set (pc)
-	(if_then_else
-	 (match_operator 1 "signed_order_operator"
-			 [(match_operand:X 2 "register_operand" "r")
-			  (const_int 0)])
-	 (label_ref (match_operand 0 "" ""))
-	 (pc)))]
-  ""
-  "b%C1z\t%2,%0"
-  [(set_attr "type" "branch")
-   (set_attr "mode" "none")])
+;; Patterns for implementations that optimize short forward branches
+
+(define_expand "mov<mode>cc"
+  [(set (match_operand:GPR 0 "register_operand")
+	(if_then_else:GPR (match_operand 1 "comparison_operator")
+			  (match_operand:GPR 2 "register_operand")
+			  (match_operand:GPR 3 "sfb_alu_operand")))]
+  "TARGET_SFB_ALU"
+{
+  rtx cmp = operands[1];
+  /* We only handle word mode integer compares for now.  */
+  if (GET_MODE (XEXP (cmp, 0)) != word_mode)
+    FAIL;
+  riscv_expand_conditional_move (operands[0], operands[2], operands[3],
+				 GET_CODE (cmp), XEXP (cmp, 0), XEXP (cmp, 1));
+  DONE;
+})
+
+(define_insn "*mov<GPR:mode><X:mode>cc"
+  [(set (match_operand:GPR 0 "register_operand" "=r,r")
+	(if_then_else:GPR
+	 (match_operator 5 "order_operator"
+		[(match_operand:X 1 "register_operand" "r,r")
+		 (match_operand:X 2 "reg_or_0_operand" "rJ,rJ")])
+	 (match_operand:GPR 3 "register_operand" "0,0")
+	 (match_operand:GPR 4 "sfb_alu_operand" "rJ,IL")))]
+  "TARGET_SFB_ALU"
+  "@
+   b%C5%y2 %1, %w2 1f; mv %0, %z4; 1: # movcc
+   b%C5%y2 %1, %w2 1f; li %0, %4; 1: # movcc"
+  [(set_attr "length" "8")
+   (set_attr "type" "sfb_alu")
+   (set_attr "mode" "<GPR:MODE>")])
 
 ;; Used to implement built-in functions.
 (define_expand "condjump"
@@ -2468,7 +2495,25 @@
   [(set_attr "length" "0")]
 )
 
+;; This fixes a failure with gcc.c-torture/execute/pr64242.c at -O2 for a
+;; 32-bit target when using -mtune=sifive-7-series.  The first sched pass
+;; runs before register elimination, and we have a non-obvious dependency
+;; between a use of the soft fp and a set of the hard fp.  We fix this by
+;; emitting a clobber using the hard fp between the two insns.
+(define_expand "restore_stack_nonlocal"
+  [(match_operand 0 "register_operand")
+   (match_operand 1 "memory_operand")]
+  ""
+{
+  emit_move_insn (operands[0], operands[1]);
+  /* Prevent the following hard fp restore from being moved before the move
+     insn above which uses a copy of the soft fp reg.  */
+  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
+  DONE;
+})
+
 (include "sync.md")
 (include "peephole.md")
 (include "pic.md")
 (include "generic.md")
+(include "sifive-7.md")
diff --git a/gcc/config/riscv/sifive-7.md b/gcc/config/riscv/sifive-7.md
new file mode 100644
index 0000000..526278e
--- /dev/null
+++ b/gcc/config/riscv/sifive-7.md
@@ -0,0 +1,128 @@
+(define_automaton "sifive_7")
+
+;; Sifive 7 Series Base Core
+;; This has two pipelines, A (Address) and B (Branch).
+;; Loads, stores, and FP <-> integer moves use the A-pipe.
+;; Branches, MUL/DIV, and FP ops use the B-pipe.
+;; Integer ALU ops can use either pipe.
+
+(define_cpu_unit "sifive_7_A" "sifive_7")
+(define_cpu_unit "sifive_7_B" "sifive_7")
+
+(define_cpu_unit "sifive_7_idiv" "sifive_7")
+(define_cpu_unit "sifive_7_fpu" "sifive_7")
+
+(define_insn_reservation "sifive_7_load" 3
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "load"))
+  "sifive_7_A")
+
+(define_insn_reservation "sifive_7_fpload" 2
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "fpload"))
+  "sifive_7_A")
+
+(define_insn_reservation "sifive_7_store" 1
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "store"))
+  "sifive_7_A")
+
+(define_insn_reservation "sifive_7_fpstore" 1
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "fpstore"))
+  "sifive_7_A")
+
+(define_insn_reservation "sifive_7_branch" 1
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "branch"))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_sfb_alu" 2
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "sfb_alu"))
+  "sifive_7_A+sifive_7_B")
+
+(define_insn_reservation "sifive_7_jump" 1
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "jump,call"))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_mul" 3
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "imul"))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_div" 16
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "idiv"))
+  "sifive_7_B,sifive_7_idiv*15")
+
+(define_insn_reservation "sifive_7_alu" 2
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "unknown,arith,shift,slt,multi,logical,move"))
+  "sifive_7_A|sifive_7_B")
+
+(define_insn_reservation "sifive_7_load_immediate" 1
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "nop,const,auipc"))
+  "sifive_7_A|sifive_7_B")
+
+(define_insn_reservation "sifive_7_sfma" 5
+  (and (eq_attr "tune" "sifive_7")
+       (and (eq_attr "type" "fadd,fmul,fmadd")
+	    (eq_attr "mode" "SF")))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_dfma" 7
+  (and (eq_attr "tune" "sifive_7")
+       (and (eq_attr "type" "fadd,fmul,fmadd")
+	    (eq_attr "mode" "DF")))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_fp_other" 3
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "fcvt,fcmp,fmove"))
+  "sifive_7_B")
+
+(define_insn_reservation "sifive_7_fdiv_s" 27
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "fdiv,fsqrt")
+       (eq_attr "mode" "SF"))
+  "sifive_7_B,sifive_7_fpu*26")
+
+(define_insn_reservation "sifive_7_fdiv_d" 56
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "fdiv,fsqrt")
+       (eq_attr "mode" "DF"))
+  "sifive_7_B,sifive_7_fpu*55")
+
+(define_insn_reservation "sifive_7_i2f" 3
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "mtc"))
+  "sifive_7_A")
+
+(define_insn_reservation "sifive_7_f2i" 3
+  (and (eq_attr "tune" "sifive_7")
+       (eq_attr "type" "mfc"))
+  "sifive_7_A")
+
+(define_bypass 1 "sifive_7_load,sifive_7_alu,sifive_7_mul,sifive_7_f2i,sifive_7_sfb_alu"
+  "sifive_7_alu,sifive_7_branch")
+
+(define_bypass 1 "sifive_7_alu,sifive_7_sfb_alu"
+  "sifive_7_sfb_alu")
+
+(define_bypass 1 "sifive_7_load,sifive_7_alu,sifive_7_mul,sifive_7_f2i,sifive_7_sfb_alu"
+  "sifive_7_store" "riscv_store_data_bypass_p")
+
+(define_bypass 2 "sifive_7_i2f"
+  "sifive_7_sfma,sifive_7_dfma,sifive_7_fp_other,sifive_7_fdiv_s,sifive_7_fdiv_d")
+
+(define_bypass 2 "sifive_7_fp_other"
+  "sifive_7_sfma,sifive_7_dfma,sifive_7_fp_other,sifive_7_fdiv_s,sifive_7_fdiv_d")
+
+(define_bypass 2 "sifive_7_fp_other"
+  "sifive_7_alu,sifive_7_branch")
+
+(define_bypass 2 "sifive_7_fp_other"
+  "sifive_7_store" "riscv_store_data_bypass_p")
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 4477b6d..4d143d0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -23081,7 +23081,16 @@ lower-case.  Examples include @samp{rv64i}, @samp{rv32g}, @samp{rv32e}, and
 @item -mtune=@var{processor-string}
 @opindex mtune
 Optimize the output for the given processor, specified by microarchitecture
-name.
+name.  Permissible values for this option are: @samp{rocket},
+@samp{sifive-3-series}, @samp{sifive-5-series}, @samp{sifive-7-series},
+and @samp{size}.
+
+When @option{-mtune=} is not specified, the default is @samp{rocket}.
+
+The @samp{size} choice is not intended for use by end-users.  This is used
+when @option{-Os} is specified.  It overrides the instruction cost info
+provided by @option{-mtune=}, but does not override the pipeline info.  This
+helps reduce code size while still giving good performance.
 
 @item -mpreferred-stack-boundary=@var{num}
 @opindex mpreferred-stack-boundary
